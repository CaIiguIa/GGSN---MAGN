pseudocode for priorities in MAGN


# Definicje
# P - Priorytet neuronu
# alpha - współczynnik uczenia
# activation - aktywacja neuronu
# delta - różnica między aktywacjami neuronów a wartością odniesienia

# Inicjalizacja priorytetów neuronów
initialize_priorities(neurons):
    for neuron in neurons:
        neuron.priority = 1.0  # Można użyć innej wartości początkowej





# Obliczanie delty dla cech ciągłych
calculate_delta_continuous(activated_neurons, reference_value):
    deltas = []
    for neuron in activated_neurons:
        delta = abs(neuron.activation - reference_value)
        deltas.append(delta)
    return normalize(deltas)

# Obliczanie delty dla cech kategorycznych
calculate_delta_categorical(activated_neurons, reference_value):
    deltas = []
    for neuron in activated_neurons:
        delta = 0 if neuron.activation == reference_value else 1
        deltas.append(delta)
    return deltas

# Normalizacja wartości delty
normalize(deltas):
    max_delta = max(deltas)
    if max_delta == 0:
        return deltas
    normalized_deltas = [delta / max_delta for delta in deltas]
    return normalized_deltas

# Aktualizacja priorytetu neuronów
update_priorities(activated_neurons, reference_value, alpha):
    if is_categorical(reference_value):
        deltas = calculate_delta_categorical(activated_neurons, reference_value)
    else:
        deltas = calculate_delta_continuous(activated_neurons, reference_value)

    for i, neuron in enumerate(activated_neurons):
        delta = deltas[i]
        if delta == 0:
            neuron.priority *= (1 + alpha * neuron.activation)
        else:
            neuron.priority *= (1 - alpha * delta * neuron.activation)

# Główny algorytm priorytetyzacji
MAGN_prioritization_algorithm(training_data, alpha, epochs):
    neurons = extract_neurons_from_data(training_data)
    initialize_priorities(neurons)

    for epoch in range(epochs):
        for example in training_data:
            target_feature = get_target_feature(example)
            activated_neurons = activate_sensors(example, target_feature)
            reference_value = get_reference_value(example, target_feature)
            update_priorities(activated_neurons, reference_value, alpha)

# Funkcje pomocnicze
is_categorical(value):
    return isinstance(value, str)

get_target_feature(example):
    # Zwraca cechę docelową dla danego przykładu
    return example.target_feature

activate_sensors(example, target_feature):
    # Aktywuje sensory (węzły cech) dla danego przykładu, z wyłączeniem cechy docelowej
    activated_neurons = []
    for feature, value in example.features.items():
        if feature != target_feature:
            neuron = activate_sensor(feature, value)
            activated_neurons.append(neuron)
    return activated_neurons

get_reference_value(example, target_feature):
    # Zwraca wartość odniesienia dla cechy docelowej
    return example.features[target_feature]

activate_sensor(feature, value):
    # Aktywuje sensor (węzeł cechy) dla danej cechy i wartości
    return Neuron(feature, value)

# Klasa Neuron (sensor)
class Neuron:
    def __init__(self, feature, value):
        self.feature = feature
        self.activation = value
        self.priority = 1.0  # Wartość początkowa priorytetu
